#  Copyright 2025 Dell Inc. or its subsidiaries. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""
This module provides functions for managing inventory files
    based on node information from a database.
"""

import os
import json
import sys
import logging
from typing import List, Tuple
import argparse
import commentedconfigparser

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class InventoryManager:
    """Inventory tagging module.
    Handles inventory updates and database interactions for nodes.
    """
    def __init__(self, inventory_filenames, vendors, inventory_dir_path, path_to_db_file):
        """
        Initializes an InventoryManager object.

        Parameters:
            inventory_filenames (List[str]): A list of filenames for the inventory.
            vendors (List[str]): A list of vendors.
            inventory_dir_path (str): The path to the inventory directory.
            path_to_db_file (str): The path to the database file.

        Returns:
            None
        """
        self.inventory_filenames = inventory_filenames
        self.vendors = vendors
        self.inventory_dir_path = os.path.abspath(inventory_dir_path)
        self.db_path = path_to_db_file

    def add_inventory_files(self) -> None:
        """
        Create inventory files based on the configured filenames.
        This method iterates over the filenames in `self.inventory_filenames`
            and creates a file in the `self.inventory_dir_path` directory.
        The file is opened in write mode and the inventory header is written to it.
        The group name is also written to the file.

        Parameters:
            self (InventoryManager): The InventoryManager object.

        Returns:
            None
        """
        inventory_header = "# This file is generated by omnia, and should not be edited\n"
        # Create the directory if it doesn't exist
        if not os.path.exists(self.inventory_dir_path):
            os.makedirs(self.inventory_dir_path, mode=0o644)  # Use directory permissions
        # Iterate over the inventory filenames
        for filename in self.inventory_filenames:
            file_path = os.path.join(self.inventory_dir_path, filename)
            file_path = os.path.abspath(file_path)
            with open(file_path, 'w', encoding='utf-8') as file:
                # Write the header to the file
                file.write(inventory_header)
                # Write the group name to the file
                if filename != "cluster_layout":
                    group_name = f"[{filename}]\n"
                    file.write(group_name)
                file.flush()

    def get_cluster_details_db(self) -> List[Tuple[str, str, str, str, str, str, str, str]]:
        """
        Retrieves the details of the cluster from the database.

        This method retrieves the details of the cluster from the database.
        It first checks if the `db_path` attribute is set. If it is, it inserts
        the `db_path` into `sys.path` to ensure that the module can be imported.
        It then tries to import the `create_connection` module from the
        `omniadb_connection` package. If the import fails, it logs an error
        message and returns an empty list.

        If the import is successful, it establishes a connection to the
        database using the `create_connection` function. It then executes a
        SQL query to fetch the details of the nodes with the status 'booted'
        from the `cluster.nodeinfo` table. The fetched data is returned.

        Parameters:
            self (InventoryManager): The InventoryManager object.

        Returns:
            List[Tuple[str, str, str, str, str, str, str, str]]: A list of tuples containing
            the details of the nodes with the status 'booted'. Each tuple
            contains the node, service tag, hostname, admin IP, CPU, GPU, role, cluster_name.
        """
        if self.db_path:
            sys.path.insert(0, self.db_path)
            try:
                # pylint: disable=C0415
                from omniadb_connection import create_connection
            except ImportError:
                logger.error("Failed to import omniadb_connection module from db_path: %s",
                             self.db_path)
                return []
            with create_connection() as conn:
                cursor = conn.cursor()
                query = """
                    SELECT
                        node,
                        service_tag,
                        hostname,
                        admin_ip,
                        cpu,
                        gpu,
                        role,
                        cluster_name
                    FROM
                        cluster.nodeinfo
                    WHERE
                        status = 'booted'
                """
                cursor.execute(query)
                nodes_info = cursor.fetchall()
                return nodes_info
        else:
            logger.error("The value is missing for db_path: %s", self.db_path)
            return []

    def add_hostname_inventory(self, inventory_file: str, hostname: str) -> None:
        """
        Adds a hostname to the inventory file.

        Parameters:
            inventory_file (str): The path to the inventory file.
            hostname (str): The hostname to add.

        Returns:
            None

        Raises:
            KeyError: If the hostname is already in the file.
            OSError, Exception: If there is an error adding the hostname to the file.
        This function reads the contents of the inventory file and
            checks if the hostname is already present.
        If the hostname is not present, it reads the config file and checks if the section exists.
        If the section does not exist, it creates it.
        Then it sets the hostname under the correct section and writes the inventory file.
        """
        try:
            # Read Content of file if it exist
            if os.path.exists(os.path.abspath(inventory_file)):
                with open(os.path.abspath(inventory_file), 'r', encoding='utf-8') as file:
                    lines = file.readlines()
            else:
                lines = []

            if lines and any(hostname in line for line in lines):
                logger.info("Hostname '%s' already exists in %s. Skipping addition.", hostname, inventory_file)
                return

            config = commentedconfigparser.CommentedConfigParser(allow_no_value=True)
            config.read(inventory_file, encoding='utf-8')
            section = os.path.basename(inventory_file)

            if not config.has_section(section):
                config.add_section(section)

            config.set(section, hostname, None)

            # Write the inventory file
            with open(os.path.abspath(inventory_file), 'w', encoding='utf-8') as configfile:
                config.write(configfile, space_around_delimiters=False)
                configfile.flush()
        except Exception as err:
            logger.error("Error adding hostname %s to %s: %s", hostname, inventory_file, err)

    def add_hostname_cluster_layout_inventory(self, cluster_name: str, hostname: str, roles_name: str) -> None:
        """
        Adds a hostname to the cluster layout inventory file.

        Parameters:
        - cluster_name (str): The name of the cluster.
        - hostname (str): The hostname to add.
        - roles_name (str): The roles associated with the hostname.

        Returns:
        - None
        """
        try:
            # Create the file name based on the cluster name
            file_name = f"{cluster_name}_cluster_layout"
            file_path = os.path.join(self.inventory_dir_path, file_name)

            # Check if the file already exists
            if not os.path.exists(file_path):
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write("# This file is generated by omnia, and should not be edited\n")

            config = commentedconfigparser.CommentedConfigParser(allow_no_value=True)
            config.read(file_path, encoding='utf-8')

            roles_list = roles_name.strip().split(",")
            for group in roles_list:
                group = group.strip()
                if group == "default":
                    continue
                # Remove the prefix "service_" if the role name matches certain conditions
                if group.startswith("service_") and group in ["service_etcd", "service_kube_node", "service_kube_control_plane"]:
                    group = group.replace("service_", "")
                if not config.has_section(group):
                    config.add_section(group)
                config.set(group, hostname, None)

            # Write the inventory file
            with open(file_path, 'w', encoding='utf-8') as configfile:
                config.write(configfile, space_around_delimiters=False)
                configfile.flush()
        except Exception as err:
            logger.error("Error adding hostname %s to cluster layout: %s", hostname, err)

    def add_hostname_to_cluster_layout(self, inventory_file: str, hostname: str, roles_name: str) -> None:
        """
        Adds a hostname to the cluster layout inventory file.

        Parameters:
        - inventory_file (str): The name of the inventory file.
        - hostname (str): The hostname to add.
        - roles_name (str): The roles associated with the hostname.

        Returns:
        - None
        """
        try:
            # Create the file path
            file_path = os.path.join(self.inventory_dir_path, inventory_file)

            # Check if the file already exists
            if os.path.exists(file_path):
                # If the file exists, read its contents and merge with the new contents
                config = commentedconfigparser.CommentedConfigParser(allow_no_value=True)
                config.read(file_path, encoding='utf-8')
            else:
                # If the file doesn't exist, create a new config
                config = commentedconfigparser.CommentedConfigParser(allow_no_value=True)

            roles_list = roles_name.strip().split(",")
            for group in roles_list:
                group = group.strip()
                if 'default' in group:
                    continue
                else:
                    # Check if the section exists, otherwise create it
                    if not config.has_section(group):
                        config.add_section(group)

                    # Set the hostname under the correct section
                    # Use None as value since no value is required
                    config.set(group, hostname, None)

            # Write the inventory file
            with open(file_path, 'w', encoding='utf-8') as configfile:
                config.write(configfile, space_around_delimiters=False)
                configfile.flush()
        except Exception as err:
            logger.error("Error adding hostname %s to cluster layout: %s", hostname, err)

    def update_inventory(self, node_detail: Tuple[str, str, str, str, str, str, str, str]) -> None:
        """
        Update the inventory based on the given node detail.

        Parameters:
        - node_detail (Tuple[str, str, str, str, str, str, str, str]):
            A tuple containing the node detail.

        Returns:
        - None
        """
        # Unpack the node_detail tuple
        node, service_tag, hostname, admin_ip, cpu, gpu, roles_name, cluster_name = node_detail
        if not hostname:
            logger.warning("inventory_tagging:update_inventory: "
                           "hostname is unavailable for node %s; skipping inventory update", node)
            return
        try:
            if os.getcwd() != self.inventory_dir_path:
                os.chdir(self.inventory_dir_path)
        except OSError as err:
            logger.error("inventory_tagging:update_inventory: "
                         "Error changing current working directory to %s.\n"
                         "Error type: %s.\n"
                         "Error message: %s",
                         self.inventory_dir_path, type(err), str(err))
        if cpu:
            inventory_file_name = self.vendors.get("cpu", {}).get(cpu)
            if inventory_file_name:
                self.add_hostname_inventory(inventory_file_name, hostname)
            hostname_ip_str = f"{hostname} ansible_host={admin_ip}"
            self.add_hostname_inventory("compute_hostname_ip", hostname_ip_str)
        if gpu:
            inventory_file_name = self.vendors.get("gpu", {}).get(gpu)
            if inventory_file_name:
                self.add_hostname_inventory(inventory_file_name, hostname)
        if roles_name:
            if cluster_name == "":  # Add a check for empty cluster name
                inventory_file_name = "/opt/omnia/omnia_inventory/cluster_layout"
                self.add_hostname_to_cluster_layout(inventory_file_name, hostname, roles_name)
            else:
                self.add_hostname_cluster_layout_inventory(cluster_name, hostname, roles_name)

    def change_inventory_file_permission(self, inventory_files: List[str]) -> None:
        """
        Change the file permissions of the inventory files.

        This function takes a list of inventory file names and
            changes their permissions to read-only.

        Parameters:
        - inventory_files (List[str]): A list of inventory file names.

        Returns:
        - None
        """
        try:
            if os.getcwd() != self.inventory_dir_path:
                os.chdir(self.inventory_dir_path)
        except OSError as err:
            logger.error("Error changing directory to %s: %s", self.inventory_dir_path, err)
        for inventory_file in inventory_files:
            path = os.path.join(self.inventory_dir_path, inventory_file)
            try:
                os.chmod(path, 0o444)
            except OSError as err:
                logger.error("Error setting permissions on %s: %s", path, err)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Inventory Manager Configuration")
    parser.add_argument('--inventory_files', type=json.loads, help='List of inventory files.')
    parser.add_argument('--vendors', type=json.loads, help='Vendors configuration.')
    parser.add_argument('--inventory_dir_location', type=str, help='Directory path.')
    parser.add_argument('--db_path', type=str, help='Path to the database files.')
    args = parser.parse_args()

    manager = InventoryManager(
        inventory_filenames=args.inventory_files,
        vendors=args.vendors,
        inventory_dir_path=args.inventory_dir_location,
        path_to_db_file=args.db_path
    )
    manager.add_inventory_files()
    node_detail_list = manager.get_cluster_details_db()
    for info in node_detail_list:
        manager.update_inventory(info)
    manager.change_inventory_file_permission(args.inventory_files)
